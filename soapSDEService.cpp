/* soapSDEService.cpp
   Generated by gSOAP 2.8.33 for SDE.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "soapSDEService.h"

SDEService::SDEService(SQLClient* _sql) : soap(SOAP_IO_DEFAULT)
{	SDEService_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
	sql = _sql;
}

SDEService::SDEService(const SDEService& rhs)
{	soap_copy_context(this, &rhs);
}

SDEService::SDEService(const struct soap &_soap) : soap(_soap)
{ }

SDEService::SDEService(soap_mode iomode) : soap(iomode)
{	SDEService_init(iomode, iomode);
}

SDEService::SDEService(soap_mode imode, soap_mode omode) : soap(imode, omode)
{	SDEService_init(imode, omode);
}

SDEService::~SDEService()
{
	this->destroy();
}

void SDEService::SDEService_init(soap_mode imode, soap_mode omode)
{	soap_imode(this, imode);
	soap_omode(this, omode);
	static const struct Namespace namespaces[] = {
        {"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
        {"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
        {"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
        {"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
        {"ns", "urn:SDE", NULL, NULL},
        {NULL, NULL, NULL, NULL}
    };
	soap_set_namespaces(this, namespaces);
}

void SDEService::destroy()
{	soap_destroy(this);
	soap_end(this);
}

void SDEService::reset()
{	this->destroy();
	soap_done(this);
	soap_initialize(this);
	SDEService_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

#ifndef WITH_PURE_VIRTUAL
SDEService *SDEService::copy()
{	SDEService *dup = SOAP_NEW_COPY(SDEService(*(struct soap*)this));
	return dup;
}
#endif

SDEService& SDEService::operator=(const SDEService& rhs)
{	soap_copy_context(this, &rhs);
	return *this;
}

int SDEService::soap_close_socket()
{	return soap_closesock(this);
}

int SDEService::soap_force_close_socket()
{	return soap_force_closesock(this);
}

int SDEService::soap_senderfault(const char *string, const char *detailXML)
{	return ::soap_sender_fault(this, string, detailXML);
}

int SDEService::soap_senderfault(const char *subcodeQName, const char *string, const char *detailXML)
{	return ::soap_sender_fault_subcode(this, subcodeQName, string, detailXML);
}

int SDEService::soap_receiverfault(const char *string, const char *detailXML)
{	return ::soap_receiver_fault(this, string, detailXML);
}

int SDEService::soap_receiverfault(const char *subcodeQName, const char *string, const char *detailXML)
{	return ::soap_receiver_fault_subcode(this, subcodeQName, string, detailXML);
}

void SDEService::soap_print_fault(FILE *fd)
{	::soap_print_fault(this, fd);
}

#ifndef WITH_LEAN
#ifndef WITH_COMPAT
void SDEService::soap_stream_fault(std::ostream& os)
{	::soap_stream_fault(this, os);
}
#endif

char *SDEService::soap_sprint_fault(char *buf, size_t len)
{	return ::soap_sprint_fault(this, buf, len);
}
#endif

void SDEService::soap_noheader()
{	this->header = NULL;
}

::SOAP_ENV__Header *SDEService::soap_header()
{	return this->header;
}

int SDEService::run(int port)
{	if (!soap_valid_socket(this->master) && !soap_valid_socket(this->bind(NULL, port, 100)))
		return this->error;
	for (;;)
	{	if (!soap_valid_socket(this->accept()))
		{	if (this->errnum == 0) // timeout?
				this->error = SOAP_OK;
			break;
		}
		if (this->serve())
			break;
		this->destroy();
	}
	return this->error;
}

#if defined(WITH_OPENSSL) || defined(WITH_GNUTLS)
int SDEService::ssl_run(int port)
{	if (!soap_valid_socket(this->master) && !soap_valid_socket(this->bind(NULL, port, 100)))
		return this->error;
	for (;;)
	{	if (!soap_valid_socket(this->accept()))
		{	if (this->errnum == 0) // timeout?
				this->error = SOAP_OK;
			break;
		}
		if (this->ssl_accept() || this->serve())
			break;
		this->destroy();
	}
	return this->error;
}
#endif

SOAP_SOCKET SDEService::bind(const char *host, int port, int backlog)
{	return soap_bind(this, host, port, backlog);
}

SOAP_SOCKET SDEService::accept()
{	return soap_accept(this);
}

#if defined(WITH_OPENSSL) || defined(WITH_GNUTLS)
int SDEService::ssl_accept()
{	return soap_ssl_accept(this);
}
#endif

int SDEService::serve()
{
#ifndef WITH_FASTCGI
	unsigned int k = this->max_keep_alive;
#endif
	do
	{

#ifndef WITH_FASTCGI
		if (this->max_keep_alive > 0 && !--k)
			this->keep_alive = 0;
#endif

		if (soap_begin_serve(this))
		{	if (this->error >= SOAP_STOP)
				continue;
			return this->error;
		}
		if (dispatch() || (this->fserveloop && this->fserveloop(this)))
		{
#ifdef WITH_FASTCGI
			soap_send_fault(this);
#else
			return soap_send_fault(this);
#endif
		}

#ifdef WITH_FASTCGI
		soap_destroy(this);
		soap_end(this);
	} while (1);
#else
	} while (this->keep_alive);
#endif
	return SOAP_OK;
}

static int serve_ns__getLoginInfo(SDEService*);
static int serve_ns__getRegisteredClasses(SDEService*);
static int serve_ns__addOnyen(SDEService*);
static int serve_ns__registerClass(SDEService*);

int SDEService::dispatch()
{
	soap_peek_element(this);
	if (!soap_match_tag(this, this->tag, "ns:getLoginInfo"))
		return serve_ns__getLoginInfo(this);
	if (!soap_match_tag(this, this->tag, "ns:getRegisteredClasses"))
		return serve_ns__getRegisteredClasses(this);
	if (!soap_match_tag(this, this->tag, "ns:addOnyen"))
		return serve_ns__addOnyen(this);
	if (!soap_match_tag(this, this->tag, "ns:registerClass"))
		return serve_ns__registerClass(this);
	return this->error = SOAP_NO_METHOD;
}

static int serve_ns__getLoginInfo(SDEService *soap)
{	struct ns__getLoginInfo soap_tmp_ns__getLoginInfo;
	struct ns__getLoginInfoResponse soap_tmp_ns__getLoginInfoResponse;
	soap_default_ns__getLoginInfoResponse(soap, &soap_tmp_ns__getLoginInfoResponse);
	soap_default_ns__getLoginInfo(soap, &soap_tmp_ns__getLoginInfo);
	if (!soap_get_ns__getLoginInfo(soap, &soap_tmp_ns__getLoginInfo, "ns:getLoginInfo", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = soap->getLoginInfo(soap_tmp_ns__getLoginInfo.session, soap_tmp_ns__getLoginInfo.desiredOnyen, soap_tmp_ns__getLoginInfoResponse.response);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = NULL;
	soap_serializeheader(soap);
	soap_serialize_ns__getLoginInfoResponse(soap, &soap_tmp_ns__getLoginInfoResponse);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__getLoginInfoResponse(soap, &soap_tmp_ns__getLoginInfoResponse, "ns:getLoginInfoResponse", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__getLoginInfoResponse(soap, &soap_tmp_ns__getLoginInfoResponse, "ns:getLoginInfoResponse", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}

static int serve_ns__getRegisteredClasses(SDEService *soap)
{	struct ns__getRegisteredClasses soap_tmp_ns__getRegisteredClasses;
	struct ns__getRegisteredClassesResponse soap_tmp_ns__getRegisteredClassesResponse;
	soap_default_ns__getRegisteredClassesResponse(soap, &soap_tmp_ns__getRegisteredClassesResponse);
	soap_default_ns__getRegisteredClasses(soap, &soap_tmp_ns__getRegisteredClasses);
	if (!soap_get_ns__getRegisteredClasses(soap, &soap_tmp_ns__getRegisteredClasses, "ns:getRegisteredClasses", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = soap->getRegisteredClasses(soap_tmp_ns__getRegisteredClasses.session, soap_tmp_ns__getRegisteredClasses.desiredOnyen, soap_tmp_ns__getRegisteredClassesResponse.response);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = NULL;
	soap_serializeheader(soap);
	soap_serialize_ns__getRegisteredClassesResponse(soap, &soap_tmp_ns__getRegisteredClassesResponse);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__getRegisteredClassesResponse(soap, &soap_tmp_ns__getRegisteredClassesResponse, "ns:getRegisteredClassesResponse", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__getRegisteredClassesResponse(soap, &soap_tmp_ns__getRegisteredClassesResponse, "ns:getRegisteredClassesResponse", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}

static int serve_ns__addOnyen(SDEService *soap)
{	struct ns__addOnyen soap_tmp_ns__addOnyen;
	struct ns__addOnyenResponse soap_tmp_ns__addOnyenResponse;
	soap_default_ns__addOnyenResponse(soap, &soap_tmp_ns__addOnyenResponse);
	soap_default_ns__addOnyen(soap, &soap_tmp_ns__addOnyen);
	if (!soap_get_ns__addOnyen(soap, &soap_tmp_ns__addOnyen, "ns:addOnyen", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = soap->addOnyen(soap_tmp_ns__addOnyen.session, soap_tmp_ns__addOnyen.desiredOnyen, soap_tmp_ns__addOnyen.desiredPassword, soap_tmp_ns__addOnyenResponse.response);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = NULL;
	soap_serializeheader(soap);
	soap_serialize_ns__addOnyenResponse(soap, &soap_tmp_ns__addOnyenResponse);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__addOnyenResponse(soap, &soap_tmp_ns__addOnyenResponse, "ns:addOnyenResponse", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__addOnyenResponse(soap, &soap_tmp_ns__addOnyenResponse, "ns:addOnyenResponse", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}

static int serve_ns__registerClass(SDEService *soap)
{	struct ns__registerClass soap_tmp_ns__registerClass;
	struct ns__registerClassResponse soap_tmp_ns__registerClassResponse;
	soap_default_ns__registerClassResponse(soap, &soap_tmp_ns__registerClassResponse);
	soap_default_ns__registerClass(soap, &soap_tmp_ns__registerClass);
	if (!soap_get_ns__registerClass(soap, &soap_tmp_ns__registerClass, "ns:registerClass", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = soap->registerClass(soap_tmp_ns__registerClass.session, soap_tmp_ns__registerClass.desiredOnyen, soap_tmp_ns__registerClass.desiredClass, soap_tmp_ns__registerClassResponse.response);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = NULL;
	soap_serializeheader(soap);
	soap_serialize_ns__registerClassResponse(soap, &soap_tmp_ns__registerClassResponse);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__registerClassResponse(soap, &soap_tmp_ns__registerClassResponse, "ns:registerClassResponse", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__registerClassResponse(soap, &soap_tmp_ns__registerClassResponse, "ns:registerClassResponse", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}
/* End of server object code */
